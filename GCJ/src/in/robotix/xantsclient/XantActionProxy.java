package src.in.robotix.xantsclient;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This class is used by the client code to encode the Xant instructions to be
 * sent to the server side through the socket connection. The client code does
 * this by calling various methods of this class an through an instance of the
 * same that is passed to it. One place to so would be inside the
 * {@link XantClient#nextCycle(XantActionProxy)} method.
 * 
 * <pre>
 * {@code
 * 
 * // atHome, isReturning and foundFood are pre-declared boolean variables
 * 
 * 	if (proxy.isDead()) {
 * 	return;
 * 	}
 * 	if (atHome) {
 * 		proxy.dropEnergy();
 * 		return;
 * 	}
 * 	if (foundFood) {
 * 		foundFood = false;
 * 		isReturning = true;
 * 		proxy.pickEnergy();
 * 		return;
 * 	}
 * 
 * }
 * </pre>
 * */
public class XantActionProxy {

	public static final int NORMAL_CYCLE = 3;
	public static final int BROADCAST_CYCLE = 2;
	public static final int DEAD_CYCLE = 1;

	private static final String MARK_CELL = "MARK_CELL";
	private static final String READ_BROADCAST = "READ_BROADCAST";
	private static final String SEND_HINT = "SEND_HINT";
	private static final String MOVE_NORTH = "MOVE_NORTH";
	private static final String MOVE_WEST = "MOVE_WEST";
	private static final String MOVE_EAST = "MOVE_EAST";
	private static final String MOVE_SOUTH = "MOVE_SOUTH";
	private static final String DROP_ENERGY = "DROP_ENERGY";
	private static final String PICK_ENERGY = "PICK_ENERGY";

	public static final String NEIGHBOUR_MATRIX = "NEIGHBOUR_MATRIX";
	public static final String SMELL_MATRIX = "SMELL_MATRIX";
	public static final String HOME_MATRIX = "HOME_MATRIX";
	public static final String TRAIL_MATRIX = "TRAIL_MATRIX";
	public static final String OBSTACLE_MATRIX = "OBSTACLE_MATRIX";
	public static final String ENERGY_MATRIX = "ENERGY_MATRIX";

	private static Matcher deathMatcher = Pattern.compile("^ *XANT *\\{ *ID +\\d+ +DEAD *\\} *$").matcher(" ");
	private static Matcher broadcastMatcher = Pattern.compile("^ *XANT *\\{ *ID +\\d+ +XWEEN_BROADCAST +([A-Za-z0-9]+) *\\} *$").matcher(" ");
	private static Matcher normalMatcher = Pattern.compile("^ *XANT *\\{ *ID +\\d+ +ENERGY_UNITS +(\\d+) +([A-Z_]+) *\\{(.*?)\\}"
			+ " *([A-Z_]+) *\\{(.*?)\\} *([A-Z_]+) *\\{(.*?)\\} *([A-Z_]+) *\\{(.*?)\\} *([A-Z_]+) *\\{(.*?)\\} *([A-Z_]+) "
			+ "*\\{(.*?)\\} *\\}.*").matcher(" ");

	private Socket clientSocket;
	private InputStream input;
	private OutputStream output;

	private boolean normalCycle = true;

	private boolean dead = false;

	private String broadcast = null;
	private int currentEnergy;
	private HashMap<String, FlatMatrix> matrices = new HashMap<String, FlatMatrix>();
	private String exclusiveAction, inclusiveAction;

	public XantActionProxy() {
		matrices.put(ENERGY_MATRIX, null);
		matrices.put(OBSTACLE_MATRIX, null);
		matrices.put(TRAIL_MATRIX, null);
		matrices.put(HOME_MATRIX, null);
		matrices.put(SMELL_MATRIX, null);
		matrices.put(NEIGHBOUR_MATRIX, null);
	}

	/**
	 * Called to connect the application to the simulator using sockets. The
	 * participant coding his program logic need not worry about calling this
	 * method.
	 * 
	 * @param port
	 *            The port to which the client code must connect to.
	 * 
	 * @return {@code true} if the connection was established successfully and
	 *         {@code false} otherwise.
	 * */
	public boolean connect(int port) {
		try {
			clientSocket = new Socket("localhost", port);
			input = clientSocket.getInputStream();
			output = clientSocket.getOutputStream();
			writeLine("XANTS SIMULATOR 1.0 / CONNECTING XANT");
			String x = readLine();
			if (!x.equals("XANTS SIMULATOR 1.0 / CONNECTED XANT")) {
				input.close();
				output.close();
				clientSocket.close();
				return false;
			} else {
				return true;
			}
		} catch (UnknownHostException e) {
			e.printStackTrace();
			return false;
		} catch (IOException e) {
			e.printStackTrace();
			return false;
		}
	}

	/**
	 * Called to decouple the sockets. The participant need to worry about this
	 * method.
	 * 
	 * @throws IOException
	 *             Simply relays the exceptions generated by the socket classes.
	 * */
	public void disconnect() throws IOException {
		input.close();
		output.close();
		clientSocket.close();
	}

	/**
	 * Called to signify the end of one cycle of execution. The participant need
	 * not worry about calling this method.
	 * 
	 * */
	public void endCycle() {
		try {
			writeLine((exclusiveAction + " " + inclusiveAction));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Returns the current broadcast by the Xween. Participants must call this
	 * method to receive the text broadcasted by the Xween in the cycle after
	 * the one in which they generated the request.
	 * 
	 * @return A {@link String} containing the current broadcast returned by the
	 *         simulator if a valid request for a broadcast was issued in the
	 *         previous cycle. A <code>null</code> otherwise.
	 * 
	 * */
	public String getBroadcast() {
		return broadcast;
	}

	/**
	 * Returns the amount of energy the Xant is currently carrying.
	 * 
	 * @return The amount of energy the Xant is currently carrying. Returns
	 *         {@code -1} if the current simulation cycle is not a normal cycle.
	 * 
	 * */
	public int getCurrentEnergy() {
		if (normalCycle)
			return currentEnergy;
		return -1;
	}

	/**
	 * Returns the 'type' of the execution cycle. Execution cycles may of three
	 * types.
	 * <ol>
	 * <li>{@link #DEAD_CYCLE}: If the Xant is dead. An Xant dead is a
	 * particular cycle is guaranteed to be dead in all other subsequent cycles.
	 * </li>
	 * <li>{@link #BROADCAST_CYCLE}: If the Xant sent a (valid) request for an
	 * access to the Xween's current broadcast.</li>
	 * <li>{@link #NORMAL_CYCLE}: None of the above. There is nothing special
	 * about this particular cycle.
	 * </ol>
	 * 
	 * @return An integer equal in value to one of the constants mentioned
	 *         above.
	 * 
	 * */
	public int getCycleType() {
		if (dead) {
			return DEAD_CYCLE;
		} else if (broadcast != null) {
			return BROADCAST_CYCLE;
		}
		return NORMAL_CYCLE;
	}

	/**
	 * Returns a particular matrix associated with this Xant.
	 * 
	 * @return {@code null} if either the matrix does not exist or this is not a
	 *         normal cycle. Otherwise an instance of a {@link FlatMatrix}
	 *         class, representing the matrix information. Please note that the
	 *         names of the matrices have been stored as constants, which may
	 *         directly be used. The constants are {@link #SMELL_MATRIX},
	 *         {@link #NEIGHBOUR_MATRIX}, {@link #HOME_MATRIX},
	 *         {@link #TRAIL_MATRIX}, {@link #OBSTACLE_MATRIX} and
	 *         {@link #ENERGY_MATRIX}.
	 * 
	 * */
	public FlatMatrix getMatrix(String matrix) {
		if (normalCycle) {
			return matrices.get(matrix);
		}
		return null;
	}

	/**
	 * Called to parse a string returned sent by the core. Participants need not
	 * worry about calling this function.
	 * 
	 * */
	public void interpretString(String text) {
		deathMatcher.reset(text);
		if (deathMatcher.find()) {
			dead = true;
			broadcast = null;
			normalCycle = false;
			return;
		} else {
			dead = false;
		}
		broadcastMatcher.reset(text);
		if (broadcastMatcher.find()) {
			broadcast = broadcastMatcher.group(1);
			normalCycle = false;
			return;
		}
		normalMatcher.reset(text);
		if (normalMatcher.find()) {
			currentEnergy = Integer.parseInt(normalMatcher.group(1));
			for (int i = 2; i < 14; i += 2) {
				matrices.put(normalMatcher.group(i), new FlatMatrix(normalMatcher.group(i + 1)));
			}
		} else {
			throw new RuntimeException("Could not recognize text!");
		}
	}

	/**
	 * Returns {@code true} if the Xant in context is dead.
	 * */
	public boolean isDead() {
		return dead;
	}

	/**
	 * The participant calls this function to mark the current cell.
	 * */
	public void markCell() {
		inclusiveAction = MARK_CELL;
	}

	/**
	 * Participants call this method to try to move the Xant one unit toward the
	 * East.
	 * */
	public void moveEast() {
		exclusiveAction = MOVE_EAST;
	}

	/**
	 * Participants call this method to try to move the Xant one unit toward the
	 * North.
	 * */
	public void moveNorth() {
		exclusiveAction = MOVE_NORTH;
	}

	/**
	 * Participants call this method to try to move the Xant one unit toward the
	 * South.
	 * */
	public void moveSouth() {
		exclusiveAction = MOVE_SOUTH;
	}

	/**
	 * Participants call this method to try to move the Xant one unit toward the
	 * West.
	 * */
	public void moveWest() {
		exclusiveAction = MOVE_WEST;
	}

	/**
	 * Participants call this method to request for the current information
	 * being broadcasted by the Xween. The information may later be extracted by
	 * calling the function {@link #getBroadcast()}.
	 * 
	 * */
	public void readBroadcast() {
		exclusiveAction = READ_BROADCAST;
	}

	/**
	 * Participants call this method to get the Xant to pick one packet of
	 * energy from the current cell.
	 * 
	 * */
	public void pickEnergy() {
		exclusiveAction = PICK_ENERGY;
	}

	/**
	 * Participants call this method to get the Xant to drop one packet of
	 * energy onto the current cell.
	 * 
	 * */
	public void dropEnergy() {
		exclusiveAction = DROP_ENERGY;
	}

	private String readLine() throws IOException {
		StringBuffer ret = new StringBuffer();
		if (input != null) {
			int c = input.read();
			while (c != -1 && c != 10) {
				ret.append((char) ((byte) c));
				c = input.read();
			}
		}
		return ret.toString();
	}

	/**
	 * Tries to send a hint to the Xween.
	 * 
	 * @param hint
	 *            The hint to be sent.
	 * 
	 * */
	public void sendHint(String hint) {
		exclusiveAction = SEND_HINT + " " + hint;
	}

	/**
	 * Called to start a cycle. The participant need not worry about calling
	 * this method.
	 * */
	public void startCycle() {
		try {
			exclusiveAction = "";
			inclusiveAction = "";
			interpretString(readLine());
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void writeLine(String line) throws IOException {
		if (output != null) {
			byte[] bytes = (line + "\n").getBytes();
			output.write(bytes);
			output.flush();
		}
	}

}
